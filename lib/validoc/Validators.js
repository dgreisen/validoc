// Generated by CoffeeScript 1.9.1

/*
Validators are small classes that have a `validate` method. the validate method
  takes a single value. if the value is invalid throw a utils.ValidationError
 */

(function() {
  var BaseValidator, CommaSeparatedIntegerListValidator, EmailValidator, IPv46AddressValidator, IPv4AddressValidator, IPv6AddressValidator, IntegerValidator, MaxDecimalPlacesValidator, MaxDigitsValidator, MaxLengthValidator, MaxValueValidator, MinDecimalPlacesValidator, MinLengthValidator, MinValueValidator, RegexValidator, SlugValidator, URLValidator, _explode_shorthand_ip_string, ip_address_validator_map, ip_address_validators, isEmpty, utils, validators,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports !== "undefined" && exports !== null) {
    utils = require("./utils");
  } else if (typeof window !== "undefined" && window !== null) {
    utils = window.validoc.utils;
  }

  RegexValidator = (function() {

    /*
    base regex validator.  
    Attributes:
    
      * `regex`
      * `message`
      * `code` defaults to "invalid"
     */
    RegexValidator.prototype.regex = '';

    RegexValidator.prototype.message = utils._i('Enter a valid value.');

    RegexValidator.prototype.code = 'invalid';

    function RegexValidator(regex1, message, code) {
      this.regex = regex1 != null ? regex1 : this.regex;
      this.message = message != null ? message : this.message;
      this.code = code != null ? code : this.code;
      if (typeof this.regex === 'string') {
        this.regex = new RegExp(this.regex);
      }
    }

    RegexValidator.prototype.validate = function(value) {

      /*
      Validates that the input matches the regular expression.
       */
      if (!value.match(this.regex)) {
        throw new utils.ValidationError(this.message, this.code);
      }
    };

    return RegexValidator;

  })();

  URLValidator = (function(superClass) {
    extend(URLValidator, superClass);

    function URLValidator() {
      return URLValidator.__super__.constructor.apply(this, arguments);
    }

    URLValidator.prototype.regex = /^(?:http|ftp)s?:\/\/(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|localhost|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::\d+)?(?:\/?|[\/?]\S+)$/i;

    URLValidator.prototype.message = utils._i('Enter a valid URL.');

    return URLValidator;

  })(RegexValidator);

  IntegerValidator = (function() {
    function IntegerValidator() {}

    IntegerValidator.prototype.validate = function(value) {
      if (isNaN(parseInt(value))) {
        throw new utils.ValidationError('', '');
      }
    };

    return IntegerValidator;

  })();

  EmailValidator = (function(superClass) {
    extend(EmailValidator, superClass);

    function EmailValidator() {
      return EmailValidator.__super__.constructor.apply(this, arguments);
    }

    EmailValidator.prototype.regex = /(^[-!#$%&'*+\/=?^_\`{}|~0-9A-Z]+(\.[-!#$%&'*+\/=?^_\`{}|~0-9A-Z]+)*|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*")@((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?$)|\[(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\]$/i;

    EmailValidator.prototype.message = utils._i('Enter a valid e-mail address.');

    return EmailValidator;

  })(RegexValidator);

  SlugValidator = (function(superClass) {
    extend(SlugValidator, superClass);

    function SlugValidator() {
      return SlugValidator.__super__.constructor.apply(this, arguments);
    }

    SlugValidator.prototype.regex = /^[-\w]+$/;

    SlugValidator.prototype.message = utils._i("Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.");

    return SlugValidator;

  })(RegexValidator);

  IPv4AddressValidator = (function(superClass) {
    extend(IPv4AddressValidator, superClass);

    function IPv4AddressValidator() {
      return IPv4AddressValidator.__super__.constructor.apply(this, arguments);
    }

    IPv4AddressValidator.prototype.regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;

    IPv4AddressValidator.prototype.message = utils._i('Enter a valid IPv4 address.');

    return IPv4AddressValidator;

  })(RegexValidator);

  IPv6AddressValidator = (function() {
    function IPv6AddressValidator() {}

    IPv6AddressValidator.prototype.error = new utils.ValidationError(utils._i('Enter a valid IPv6 address.'), 'invalid');

    IPv6AddressValidator.prototype.validate = function(value) {
      var e, hextet, i, len1, ref, results, v;
      if (indexOf.call(value, ':') < 0) {
        throw this.error;
      }
      if (value.match(/::/g).length > 1) {
        throw this.error;
      }
      if (indexOf.call(value, ':::') >= 0) {
        throw this.error;
      }
      if ((value.match('^:') != null) || (value.match(':$') != null)) {
        throw this.error;
      }
      if (value.match(/:/g).length > 7) {
        throw this.error;
      }
      if (indexOf.call(value, '::') < 0 && value.match(/:/g).length !== 7) {
        if (value.match(/\./g).length !== 3) {
          throw this.error;
        }
      }
      value = _explode_shorthand_ip_string(value);
      ref = value.split(':');
      results = [];
      for (i = 0, len1 = ref.length; i < len1; i++) {
        hextet = ref[i];
        if (hextet.match(/\./g).length === 3) {
          v = value.split(':');
          if (!v[v.length - 1] === hextet) {
            throw this.error;
          }
          try {
            results.push(new IPv4AddressValidator().validate(hextet));
          } catch (_error) {
            e = _error;
            throw this.error;
          }
        } else {
          try {
            if (parseInt(hextet, 16) < 0x0 || parseInt(hextet, 16) > 0xFFFF) {
              throw this.error;
            } else {
              results.push(void 0);
            }
          } catch (_error) {
            e = _error;
            throw this.error;
          }
        }
      }
      return results;
    };

    return IPv6AddressValidator;

  })();

  IPv46AddressValidator = (function() {
    function IPv46AddressValidator() {}

    IPv46AddressValidator.prototype.validate = function(value) {
      var e;
      try {
        return new IPv4AddressValidator().validate(value);
      } catch (_error) {
        e = _error;
        try {
          return new IPv6AddressValidator().validate(value);
        } catch (_error) {
          e = _error;
          throw utils.ValidationError(utils._i('Enter a valid IPv4 or IPv6 address.'), 'invalid');
        }
      }
    };

    return IPv46AddressValidator;

  })();

  ip_address_validator_map = {
    both: [[IPv46AddressValidator], utils._i('Enter a valid IPv4 or IPv6 address.')],
    ipv4: [[IPv4AddressValidator], utils._i('Enter a valid IPv4 address.')],
    ipv6: [[IPv6AddressValidator], utils._i('Enter a valid IPv6 address.')]
  };

  ip_address_validators = function(protocol, unpack_ipv4) {

    /*
    Depending on the given parameters returns the appropriate validators for
    the GenericIPAddressField.
    
    This code is here, because it is exactly the same for the model and the form field.
     */
    var e;
    if (protocol !== 'both' && unpack_ipv4) {
      raise(ValueError("You can only use `unpack_ipv4` if `protocol` is set to 'both'"));
    }
    try {
      return ip_address_validator_map[protocol.lower()];
    } catch (_error) {
      e = _error;
      return raise(ValueError(utils.interpolate("The protocol '%s' is unknown. Supported: 'both', 'ipv4', 'ipv6'", [protocol])));
    }
  };

  CommaSeparatedIntegerListValidator = (function(superClass) {
    var error, regex;

    extend(CommaSeparatedIntegerListValidator, superClass);

    function CommaSeparatedIntegerListValidator() {
      return CommaSeparatedIntegerListValidator.__super__.constructor.apply(this, arguments);
    }

    regex = /^[\d,]+$/;

    error = utils._i('Enter only digits separated by commas.');

    return CommaSeparatedIntegerListValidator;

  })(RegexValidator);

  BaseValidator = (function() {
    BaseValidator.prototype.compare = function(a, b) {
      return a !== b;
    };

    BaseValidator.prototype.clean = function(x) {
      return x;
    };

    BaseValidator.prototype.message = utils._i("Ensure this value is %(limit_value)s (it is %(show_value)s).");

    BaseValidator.prototype.code = 'limit_value';

    function BaseValidator(limit_value) {
      this.limit_value = limit_value;
    }

    BaseValidator.prototype.validate = function(value) {
      var cleaned, params;
      cleaned = this.clean(value);
      params = {
        limit_value: this.limit_value,
        show_value: cleaned
      };
      if (this.compare(cleaned, this.limit_value)) {
        throw utils.ValidationError(utils.interpolate(this.message, params), this.code, params);
      }
    };

    return BaseValidator;

  })();

  MaxValueValidator = (function(superClass) {
    extend(MaxValueValidator, superClass);

    function MaxValueValidator() {
      return MaxValueValidator.__super__.constructor.apply(this, arguments);
    }

    MaxValueValidator.prototype.compare = function(a, b) {
      return a > b;
    };

    MaxValueValidator.prototype.message = utils._i('Ensure this value is less than or equal to %(limit_value)s.');

    MaxValueValidator.prototype.code = 'max_value';

    return MaxValueValidator;

  })(BaseValidator);

  MinValueValidator = (function(superClass) {
    extend(MinValueValidator, superClass);

    function MinValueValidator() {
      return MinValueValidator.__super__.constructor.apply(this, arguments);
    }

    MinValueValidator.prototype.compare = function(a, b) {
      return a < b;
    };

    MinValueValidator.prototype.message = utils._i('Ensure this value is greater than or equal to %(limit_value)s.');

    MinValueValidator.prototype.code = 'min_value';

    return MinValueValidator;

  })(BaseValidator);

  MinLengthValidator = (function(superClass) {
    extend(MinLengthValidator, superClass);

    function MinLengthValidator() {
      return MinLengthValidator.__super__.constructor.apply(this, arguments);
    }

    MinLengthValidator.prototype.x = 53;

    MinLengthValidator.prototype.compare = function(a, b) {
      return a < b;
    };

    MinLengthValidator.prototype.clean = function(x) {
      return x.length;
    };

    MinLengthValidator.prototype.message = utils._i('Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).');

    MinLengthValidator.prototype.code = 'min_length';

    return MinLengthValidator;

  })(BaseValidator);

  MaxLengthValidator = (function(superClass) {
    extend(MaxLengthValidator, superClass);

    function MaxLengthValidator() {
      return MaxLengthValidator.__super__.constructor.apply(this, arguments);
    }

    MaxLengthValidator.prototype.compare = function(a, b) {
      return a > b;
    };

    MaxLengthValidator.prototype.clean = function(x) {
      return x.length;
    };

    MaxLengthValidator.prototype.message = utils._i('Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).');

    MaxLengthValidator.prototype.code = 'max_length';

    return MaxLengthValidator;

  })(BaseValidator);

  MaxDecimalPlacesValidator = (function(superClass) {
    extend(MaxDecimalPlacesValidator, superClass);

    function MaxDecimalPlacesValidator() {
      return MaxDecimalPlacesValidator.__super__.constructor.apply(this, arguments);
    }

    MaxDecimalPlacesValidator.prototype.compare = function(a, b) {
      return a > b;
    };

    MaxDecimalPlacesValidator.prototype.clean = function(x) {
      return String(x.split(".")[1] || "").length;
    };

    MaxDecimalPlacesValidator.prototype.message = utils._i('Ensure this value has at most %(limit_value)d digits after the decimal.');

    return MaxDecimalPlacesValidator;

  })(BaseValidator);

  MinDecimalPlacesValidator = (function(superClass) {
    extend(MinDecimalPlacesValidator, superClass);

    function MinDecimalPlacesValidator() {
      return MinDecimalPlacesValidator.__super__.constructor.apply(this, arguments);
    }

    MinDecimalPlacesValidator.prototype.compare = function(a, b) {
      return a < b;
    };

    MinDecimalPlacesValidator.prototype.clean = function(x) {
      return String(x.split(".")[1] || "").length;
    };

    MinDecimalPlacesValidator.prototype.message = utils._i('Ensure this value has at least %(limit_value)d digits after the decimal.');

    return MinDecimalPlacesValidator;

  })(BaseValidator);

  MaxDigitsValidator = (function(superClass) {
    extend(MaxDigitsValidator, superClass);

    function MaxDigitsValidator() {
      return MaxDigitsValidator.__super__.constructor.apply(this, arguments);
    }

    MaxDigitsValidator.prototype.compare = function(a, b) {
      return a > b;
    };

    MaxDigitsValidator.prototype.clean = function(x) {
      return String(x).replace('.', '').length;
    };

    MaxDigitsValidator.prototype.message = utils._i('Ensure this value has at most %(limit_value)d digits.');

    return MaxDigitsValidator;

  })(BaseValidator);

  isEmpty = function(val) {
    var emptyValues;
    emptyValues = [null, void 0, ''];
    if (indexOf.call(emptyValues, val) >= 0) {
      return true;
    } else {
      return false;
    }
  };

  validators = {
    RegexValidator: RegexValidator,
    URLValidator: URLValidator,
    IntegerValidator: IntegerValidator,
    EmailValidator: EmailValidator,
    SlugValidator: SlugValidator,
    IPv4AddressValidator: IPv4AddressValidator,
    IPv6AddressValidator: IPv6AddressValidator,
    IPv46AddressValidator: IPv46AddressValidator,
    ip_address_validators: ip_address_validators,
    CommaSeparatedIntegerListValidator: CommaSeparatedIntegerListValidator,
    BaseValidator: BaseValidator,
    MaxValueValidator: MaxValueValidator,
    MinValueValidator: MinValueValidator,
    MinLengthValidator: MinLengthValidator,
    MaxLengthValidator: MaxLengthValidator,
    isEmpty: isEmpty
  };

  if (typeof window !== "undefined" && window !== null) {
    window.validoc.validators = validators;
  } else if (typeof exports !== "undefined" && exports !== null) {
    module.exports = validators;
  }

  _explode_shorthand_ip_string = function(ip_str) {

    /*
    Expand a shortened IPv6 address.
    
    Args:
        ip_str: A string, the IPv6 address.
    
    Returns:
        A string, the expanded IPv6 address.
     */
    var _, fill_to, hextet, i, j, len1, len2, ref, ref1, sep;
    if (!utils._is_shorthand_ip(ip_str)) {
      return ip_str;
    }
    newutils._ip = [];
    hextet = ip_str.split('::');
    if (indexOf.call(ip_str.split(':')[-1], '.') >= 0) {
      fill_to = 7;
    } else {
      fill_to = 8;
    }
    if (len(hextet) > 1) {
      sep = len(hextet[0].split(':')) + len(hextet[1].split(':'));
      newutils._ip = hextet[0].split(':');
      ref = xrange(fill_to - sep);
      for (i = 0, len1 = ref.length; i < len1; i++) {
        _ = ref[i];
        newutils._ip.push('0000');
      }
      newutils._ip += hextet[1].split(':');
    } else {
      newutils._ip = ip_str.split(':');
    }
    retutils._ip = [];
    ref1 = newutils._ip;
    for (j = 0, len2 = ref1.length; j < len2; j++) {
      hextet = ref1[j];
      retutils._ip.push(('0' * (4 - len(hextet)) + hextet).lower());
    }
    return ':'.join(retutils._ip);
  };

  utils._is_shorthand_ip = function(ip_str) {

    /*Determine if the address is shortened.
    
    Args:
        ip_str: A string, the IPv6 address.
    
    Returns:
        A boolean, True if the address is shortened.
     */
    if (ip_str.match(/::/g).length === 1) {
      return true;
    }
    if (_.any(ip_str.split(':'), function(x) {
      return x.length < 4;
    })) {
      return true;
    }
    return false;
  };

}).call(this);
