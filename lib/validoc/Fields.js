// Generated by CoffeeScript 1.9.1

/*
the base Field class and most of the core fields.
 */

(function() {
  var BooleanField, CharField, ChoiceField, EmailField, Field, FloatField, IntegerField, NullBooleanField, RegexField, ValidationError, _, fields, utils, validators,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (typeof exports !== "undefined" && exports !== null) {
    utils = require("./utils");
    validators = require("./Validators");
    _ = require("underscore");
  } else if (typeof window !== "undefined" && window !== null) {
    utils = window.validoc.utils;
    validators = window.validoc.validators;
    _ = window._;
  }

  ValidationError = utils.ValidationError;

  Field = (function() {

    /*
    Baseclass for all fields. Fields are defined by a schema. 
    You can override attributes and methods within the schema. 
    For example:
    
        var simpleSchema = { name: "firstField"
                           , field: "Field"
                           , required: false
                           };
    
    will create a basic field that is not required.
    This is not particularly useful.
    But we can create useful fields using subclasses of Field:
    
        var pwSchema = { name: "badPasswordField"
                       , field: "CharField"
                       , maxLength: 8
                       , minLength: 4
                       , widget: "Widgets.PasswordWidget"
                       };
    
    Now we have created a very insecure password field schema.
    We have overridden the Charfield's default widget with a password widget.
    
    We create a Field instance from a schema by calling:
    
        simpleField = validoc.genField(simpleSchema, opts);
    
    `opts` is an optional hash explained later.
    
    Your schema is a JavaScript object,
    so it can define both attributes and methods for the resulting Field.
    While in Django you would have to create a custom Field subclass for a one-off field with custom validation,
    in ValiDoc, you can simply override the clean() method.
    You can then optionally turn that schema into its own reusable field if you need to use it again later Any defaults can be overridden by subclasses
    The following attributes can be specified in the schema.
      
      * `field`: the field type (e.g. CharField, ContainerField) (required)
      * `name`: the name/identifier for this field (required)
      * `widget`: widget constructor hash or string name
         (e.g. { widget: "widget.Widget"}, or simply "widget.Widget")
         (default: depends on Field type)
      * `required`: whether the current field is required (default: true)
      * `default`: the default value of the field.
        If the value is undefined, the value will be set to the default value.
    
    The following attributes can also technically be specified in the schema,
    but in practice, the should only have to be modified by subclasses:
    
      * `errorMessages`: hash of error message codes and keys.
        You can override any error message by setting a new message for the code.
      * `validators`: array of validators;
        If overriding a parent class, you must include all ancestor validators
    
    Just like with django forms, you can create a bound or unbound field.
    A bound field has been bound to data that needs to be validated.
    An unbound field has no data to validate, 
    and is usually used to generate a user interface.
    In ValiDoc, you bind a field to data by passing a `value` in the opts.
    One of the major shortcomings of Django forms is that you cannot validate
    data transitions, only data states. ValiDoc solves this by letting you pass
    an `initialValue`, in addition to `value`. Your `clean` method 
    
      * `value`: the current value of the field
      * `initialValue`: the initial value of the field (useful for custom validation)
      * `fullyDescribed`: whether the schema must fully describe the value. (default: false)
    
    You are probably doing something wrong if you access an attribute
    that starts with an underscore. You should **never** directly modify
    any attribute that starts with an underscore.
     */
    Field.prototype.name = void 0;

    Field.prototype.required = true;

    Field.prototype.defaultWidget = "TextInput";

    Field.prototype["default"] = void 0;

    Field.prototype.validators = [];

    Field.prototype.errorMessages = {
      required: utils._i('This field is required.')
    };

    Field.prototype._clean = void 0;

    Field.prototype._errors = [];

    Field.prototype._parent = void 0;

    Field.prototype._value = void 0;

    Field.prototype._initialValue = void 0;

    function Field(schema, opts, parent) {
      var schemaErrorMessages, schemaValidators;
      if (parent != null) {
        this._parent = parent;
      }
      if (schema == null) {
        schema = {};
      }
      if (opts == null) {
        opts = {};
      }
      this._rawSchema = _.clone(schema);
      this._rawOpts = _.clone(opts);
      schemaErrorMessages = utils.objPop(schema, 'errorMessages') || {};
      this.errorMessages = this._walkProto("errorMessages");
      _.extend(this.errorMessages, schemaErrorMessages);
      schemaValidators = utils.objPop(schema, 'validators') || [];
      this.validators = this._walkProto("validators");
      this.validators = this.validators.concat(schemaValidators);
      this._errors = [];
      this.setSchema(schema);
      this.setOpts(opts);
    }

    Field.prototype._walkProto = function(attr) {

      /* walks the prototype chain collecting all the values off attr and combining them in one. */
      var sup;
      sup = this.constructor.__super__;
      if (sup != null) {
        if (_.isArray(this[attr])) {
          return this[attr].concat(sup._walkProto(attr));
        } else {
          return _.extend(sup._walkProto(attr), this[attr]);
        }
      } else {
        return _.clone(this[attr]);
      }
    };

    Field.prototype.getErrors = function() {

      /* get the errors for this field. */
      this.isValid();
      if (this._errors.length) {
        return this._errors;
      } else {
        return [];
      }
    };

    Field.prototype.toJavascript = function(value) {

      /*
      First function called in validation process.<br />
      this function converts the raw value to javascript. `value` is the raw value from
      `@getValue()`. The function returns the value in the proper javascript format,<br />
      this function should be able to convert from any type that a widget might supply to the type needed for validation
       */
      return value;
    };

    Field.prototype.validate = function(value, initialValue, opts) {

      /*
      Second function called in validation process.<br />
      Any custom validation logic should be placed here. receives the input, `value`, from `toJavascript`'s output.
      return the value with any modifications. When validation fails, throw a utils.ValidationError. with a 
      default error message, a unique error code, and any attributes for string interpolation of the error message
      be sure to call `@super <br />
      default action is to check if the field is required
       */
      if (validators.isEmpty(value) && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    Field.prototype.runValidators = function(value, initialValue, opts) {

      /*
      Third function called in validation process.<br />
      You should not have to override this function. simply add validators to @validators.
       */
      var i, len, ref, v;
      if (validators.isEmpty(value)) {
        return;
      }
      ref = this.validators;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        this._catchErrors(v, value, opts);
      }
      return value;
    };

    Field.prototype.isValid = function() {

      /* primary validation function<br />
      calls all other validation subfunctions.
      returns `true` or `false`
       */
      var initialValue, valid, value;
      if (this._valid != null) {
        return this._valid;
      }
      value = this.getValueForCleaning();
      initialValue = this.getInitialValue();
      value = this._catchErrors(this.toJavascript, value, initialValue, this.opts);
      if (!this._errors.length) {
        value = this._catchErrors(this.validate, value, initialValue, this.opts);
      }
      if (!this._errors.length) {
        value = this.runValidators(value, initialValue, this.opts);
      }
      valid = !this._errors.length;
      this._clean = valid ? value : void 0;
      this._valid = valid;
      return valid;
    };

    Field.prototype._catchErrors = function(fn, value, initialValue, opts) {

      /* helper function for running an arbitrary function, capturing errors and placing in error array */
      var e, message;
      try {
        if (_.isFunction(fn)) {
          value = fn.call(this, value, initialValue, opts);
        } else {
          value = fn.validate(value, initialValue, opts);
        }
      } catch (_error) {
        e = _error;
        message = this.errorMessages[e.code] != null ? this.errorMessages[e.code] : e.message;
        if (e.params != null) {
          message = utils.interpolate(message, e.params);
        }
        this._errors.push(message);
      }
      return value;
    };

    Field.prototype.getClean = function() {

      /*
      return the field's cleaned data if there are no errors.
      throws an error if there are validation errors.
      you should not need to override this in Field subclasses
       */
      this._throwErrorIfInvalid();
      return this._clean;
    };

    Field.prototype.toJSON = function() {

      /*
      return the field's cleaned data in serializable form if there are no errors.
      throws an error if there are validation errors.
      you might have to override this in Field subclasses.
       */
      return this.getClean();
    };

    Field.prototype.setOpts = function(opts) {
      this._initialValue = utils.objPop(opts, 'initialValue') || opts.value;
      this._value = utils.objPop(opts, 'value');
      if (this._value == null) {
        this._value = _.clone(this["default"]);
      }
      return this.opts = _.clone(opts);
    };

    Field.prototype.setSchema = function(schema) {
      return _.extend(this, schema);
    };

    Field.prototype.getValue = function() {

      /* You should not have to override this in Field subclasses */
      return this._value;
    };

    Field.prototype.getValueForCleaning = function() {

      /* Should only need to be overridden by container subclasses */
      return this.getValue();
    };

    Field.prototype.getInitialValue = function() {
      return this._initialValue;
    };

    Field.prototype.getPath = function() {

      /*
      Get an array of the unique path to the field.
      A ListField's subfields are denoted by an integer representing the index of the subfield.
      A ContainerField's subfields are denoted by a string or integer representing the key of the subfield.
      Example:
      {parent: {child1: hello, child2: [the, quick, brown, fox]}}
      ["parent", "child2", 1] points to "quick"
      [] points to {parent: {child1: hello, child2: [the, quick, brown, fox]}}
       */
      if (this._parent) {
        return this._parent.getPath(this);
      } else {
        return [];
      }
    };

    Field.prototype.getField = function(path) {

      /* get a field given a path */
      if (path.length > 0) {
        return void 0;
      } else {
        return this;
      }
    };

    Field.prototype._throwErrorIfInvalid = function() {
      if (!this.isValid()) {
        throw this._errors;
      }
    };

    return Field;

  })();

  CharField = (function(superClass) {
    extend(CharField, superClass);


    /*
    a field that contains a string.  
    Attributes:
    
     * `maxLength`: The maximum length of the string (optional)
     * `minLength`: The minimum length of the string (optional)
    
    Default widget: TextInput
     */

    CharField.prototype.maxLength = void 0;


    /* The minimum length of the string (optional) */

    CharField.prototype.minLength = void 0;

    function CharField(schema, opts, parent) {
      CharField.__super__.constructor.call(this, schema, opts, parent);
      if (this.maxLength != null) {
        this.validators.push(new validators.MaxLengthValidator(this.maxLength));
      }
      if (this.minLength != null) {
        this.validators.push(new validators.MinLengthValidator(this.minLength));
      }
    }

    CharField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    return CharField;

  })(Field);

  IntegerField = (function(superClass) {
    extend(IntegerField, superClass);


    /*
    a field that contains a whole number.  
    Attributes:  
    
     * `maxValue`: Maximum value of integer
     * `minValue`: Minimum value of integer
    
    Default widget: TextInput
     */

    IntegerField.prototype.maxValue = void 0;

    IntegerField.prototype.minValue = void 0;

    IntegerField.prototype.errorMessages = {
      invalid: utils._i('Enter a whole number.')
    };

    function IntegerField(schema, opts, parent) {
      IntegerField.__super__.constructor.call(this, schema, opts, parent);
      if (this.maxValue != null) {
        this.validators.push(new validators.MaxValueValidator(this.maxValue));
      }
      if (this.minValue != null) {
        this.validators.push(new validators.MinValueValidator(this.minValue));
      }
    }

    IntegerField.prototype.parseFn = parseInt;

    IntegerField.prototype.regex = /^-?\d*$/;

    IntegerField.prototype.toJavascript = function(value) {
      if (typeof value === "string" && !value.match(this.regex)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      value = validators.isEmpty(value) ? void 0 : this.parseFn(value, 10);
      if ((value != null) && isNaN(value)) {
        throw ValidationError(this.errorMessages.invalid, "invalid");
      }
      return value;
    };

    return IntegerField;

  })(Field);

  FloatField = (function(superClass) {
    extend(FloatField, superClass);


    /*
    A field that contains a floating point number.  
    Attributes:
    
      * `maxDecimals`: Maximum number of digits after the decimal point
      * `minDecimals`: Minimum number of digits after the decimal point
      * `maxDigits`: Maximum number of total digits before and after the decimal point
    
    Default widget: TextInput
     */

    FloatField.prototype.maxDecimals = void 0;

    FloatField.prototype.minDecimals = void 0;

    FloatField.prototype.maxDigits = void 0;

    FloatField.prototype.errorMessages = {
      invalid: utils._i('Enter a number.')
    };

    function FloatField(schema, opts, parent) {
      FloatField.__super__.constructor.call(this, schema, opts, parent);
      if (this.maxDecimals != null) {
        this.validators.push(new validators.MaxDecimalPlacesValidator(this.maxDecimals));
      }
      if (this.minDecimals != null) {
        this.validators.push(new validators.MinDecimalPlacesValidator(this.minDecimals));
      }
      if (this.maxDigits != null) {
        this.validators.push(new validators.MaxDigitsValidator(this.maxDigits));
      }
    }

    FloatField.prototype.parseFn = parseFloat;

    FloatField.prototype.regex = /^\d*\.?\d*$/;

    return FloatField;

  })(IntegerField);

  RegexField = (function(superClass) {
    extend(RegexField, superClass);


    /*
    A baseclass for subclassing.
    Attributes:
    
      * `regex`: the compiled regex to test against
      * `errorMessage`: the error message to display when the regex fails
    
    Default widget: TextInput
     */

    RegexField.prototype.regex = void 0;

    RegexField.prototype.errorMessage = void 0;

    function RegexField(schema, opts, parent) {
      RegexField.__super__.constructor.call(this, schema, opts, parent);
      this.validators.push(new validators.RegexValidator(this.regex));
      if (this.errorMessage) {
        this.errorMessages.invalid = this.errorMessage;
      }
    }

    return RegexField;

  })(Field);

  EmailField = (function(superClass) {
    extend(EmailField, superClass);

    function EmailField() {
      return EmailField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a valid email.  
    Attributes:
    
      * None
    
    Default widget: EmailInput
     */

    EmailField.prototype.widget = "EmailInput";

    EmailField.prototype.validators = [new validators.EmailValidator()];

    return EmailField;

  })(RegexField);

  BooleanField = (function(superClass) {
    extend(BooleanField, superClass);

    function BooleanField() {
      return BooleanField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a Boolean value. Must be true or false.
    if you want to be able to store null us `NullBooleanField`
    Attributes:
    
      * none
    
    Default widget: CheckboxInput
     */

    BooleanField.prototype.widget = "CheckboxInput";

    BooleanField.prototype.toJavascript = function(value) {
      var ref;
      if (typeof value === "string" && ((ref = value.toLowerCase()) === "false" || ref === "0")) {
        value = false;
      } else {
        value = Boolean(value);
      }
      if (!value && this.required) {
        throw ValidationError(this.errorMessages.required, "required");
      }
      return value;
    };

    return BooleanField;

  })(Field);

  NullBooleanField = (function(superClass) {
    extend(NullBooleanField, superClass);

    function NullBooleanField() {
      return NullBooleanField.__super__.constructor.apply(this, arguments);
    }


    /*
    A field that contains a Boolean value. The value can be 
    true, false, or null.  
    Attributes:
    
      * none
    
    Default widget: CheckboxInput
     */

    NullBooleanField.prototype.toJavascript = function(value) {
      if (value === true || value === "True" || value === "1") {
        value = true;
      } else if (value === false || value === "False" || value === "0") {
        value = false;
      } else {
        value = null;
      }
      return value;
    };

    NullBooleanField.prototype.validate = function(value) {
      return value;
    };

    return NullBooleanField;

  })(BooleanField);

  ChoiceField = (function(superClass) {
    extend(ChoiceField, superClass);


    /*
    A field that contains value from a list of values.  
    Attributes:
    
      * `choices`: Array of 2-arrays specifying valid choices. if 2-arrays, first value is value, second is display. create optgroups by setting display If display value to a 2-array. MUST USE `setChoices`.
    
    Default widget: Select
     */

    ChoiceField.prototype.widget = "Select";

    ChoiceField.prototype.choices = [];

    ChoiceField.prototype.errorMessages = {
      invalidChoice: utils._i('Select a valid choice. %(value)s is not one of the available choices.')
    };

    function ChoiceField(schema, opts, parent) {
      if (opts.choices) {
        this.choices = opts.choices;
      }
      this.setChoices(_.clone(this.choices));
      ChoiceField.__super__.constructor.call(this, schema, opts, parent);
    }

    ChoiceField.prototype.setChoices = function(val) {
      var choices, iterChoices;
      choices = {};
      iterChoices = function(x) {
        if (x[1] instanceof Array) {
          return _.forEach(x[1], iterChoices);
        } else {
          return choices[x[0]] = x[1];
        }
      };
      _.forEach(this.choices, iterChoices);
      return this.choicesIndex = choices;
    };

    ChoiceField.prototype.toJavascript = function(value) {
      value = validators.isEmpty(value) ? "" : value;
      return value;
    };

    ChoiceField.prototype.validate = function(value) {
      value = ChoiceField.__super__.validate.call(this, value);
      if (value && !this.validValue(value)) {
        throw ValidationError(this.errorMessages.invalidChoice, "invalidChoice", value);
      }
      return value;
    };

    ChoiceField.prototype.validValue = function(val) {
      return val in this.choicesIndex;
    };

    ChoiceField.prototype.getDisplay = function() {
      return this.choices[this.getClean()];
    };

    return ChoiceField;

  })(Field);

  fields = {
    Field: Field,
    CharField: CharField,
    IntegerField: IntegerField,
    FloatField: FloatField,
    RegexField: RegexField,
    EmailField: EmailField,
    BooleanField: BooleanField,
    NullBooleanField: NullBooleanField,
    ChoiceField: ChoiceField,
    getField: function(path) {
      var i, len, out, part;
      path = path.split(".");
      out = this;
      for (i = 0, len = path.length; i < len; i++) {
        part = path[i];
        out = out[part];
      }
      return out;
    },
    genField: function(schema, opts, parent) {
      var field;
      schema = _.clone(schema);
      field = this.getField(schema.field);
      if (!field) {
        throw Error("Unknown field: " + schema.field);
      }
      return new field(schema, opts, parent);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.validoc.fields = fields;
  } else if (typeof exports !== "undefined" && exports !== null) {
    module.exports = fields;
  }

}).call(this);
